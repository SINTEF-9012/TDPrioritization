"**Prioritized Technical‑Debt Fixing Order**

| # | Smell (name) | Type | File | Reason for prioritization |
|---|---------------|------|------|---------------------------|
| **1** | **Long Method – `fine_tune_model`** | Code | `../projects/text_classification/app.py` | This method drives the entire fine‑tuning pipeline, is 77 lines long, and sits in a 380‑LOC file whose maintainability index is only 48.33. With a single developer touch and a recent commit (within the last 196 days), the cost of refactoring is relatively low, but the functional impact is high – any regression in fine‑tuning will break downstream training and evaluation jobs. |
| **2** | **Long Method – `compute_metrics`** | Code | `../projects/text_classification/tdsuite/utils/metrics.py` | The method is 118 lines with a cyclomatic complexity of 28, directly determining all model‑evaluation reports. It is called from multiple stages (training, inference, reporting). Its high complexity poses a high propagation risk; a subtle bug would corrupt performance metrics everywhere. Despite the file having moderate churn (412 lines changed), correcting this single long method yields instant quality gains. |
| **3** | **Long Method – `main` in inference** | Code | `../projects/text_classification/tdsuite/inference.py` | Inference is the public API for end‑users; the main routine is 127 lines, with a cyclomatic complexity of 12 and a maintainability index of 58.78. The file has high churn (474 lines) and has not been updated for 194 days, indicating that it is likely frozen in a fragile state. Fixing this will reduce the risk of runtime crashes and improve user experience. |
| **4** | **Structural – Long File – `td_trainer.py`** | Structural | `../projects/text_classification/tdsuite/trainers/td_trainer.py` | The file contains 294 meaningful lines of code and has a maintainability index of 54.38. It’s a core component (trainer) used by both training and inference scripts. Although labeled “Medium” severity, its size and recent churn (576 lines changed across 3 commits) make it a significant maintenance burden. Refactoring the file into smaller, focused classes will cut future regression risk. |
| **5** | **Long Method – `split_data`** | Code | `../projects/text_classification/tdsuite/data/data_splitter.py` | This 73‑line routine splits raw datasets before training. While its cyclomatic complexity is moderate (6.71) and maintainability is 55.71, the method is invoked during every training run, meaning errors would propagate to downstream data pipelines. Refactoring will improve clarity and allow easier unit‑testing of the split logic. |
| **6** | **Long Method – `main` in train** | Code | `../projects/text_classification/tdsuite/train.py` | The training script has 88 lines of main logic, cyclomatic complexity of 2.5, and a maintainability of 73.82 – comparatively good. It runs a one‑liner training pipeline that is rarely changed (2 commits, 195 days ago). Because complexity and churn are low, it is a lower‑priority fix; future work would focus on bigger components. |
| **7** | **Long Method – `main` in hf_upload_example** | Code | `../projects/text_classification/hf_upload_example.py` | Example scripts are seldom used in production; this 50‑line method is in an 84‑LOC file with high maintainability (71.86). Given its limited propagation scope and low impact on core functionality, it lands near the bottom of the list. |
| **8** | **Long Method – `generate_model_card`** | Code | `../projects/text_classification/tdsuite/upload_to_hf.py` | Despite being 67 lines long, it resides in an example‑level utility with moderate complexity (3.25). The file’s maintainability index is 52.04, but the routine is only used for documentation generation on demand, so its refactoring yields the lowest immediate benefit among the smells. |

**Why this order?**

1. **Impact on core logic** – The top‑four smells are directly involved in training, inference, or metric calculation, all of which affect the delivered product’s accuracy and reliability.  
2. **Propagation risk** – Methods with high cyclomatic complexity (e.g., `compute_metrics`, `inference main`) carry a higher chance of regression when changed.  
3. **Cost–benefit ratio** – The early items require relatively low effort (single method or moderate‑sized file) but unlock significant quality improvements immediately.  
4. **Maintenance history** – Smells with high churn and long periods since last change suggest that the code may be frozen and more fragile; they deserve earlier attention.  
5. **Scope of use** – Example‑only and documentation‑generation smells have the narrowest usage, so fixing them later reduces the risk of affecting the main product.  

By applying this ranking, the team can focus on the most valuable refactorings first, achieving incremental improvements in quality while managing technical‑debt costs effectively."
