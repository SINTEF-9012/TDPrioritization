"You are a prioritization agent specialized in software quality and technical debt management.

Your task is to prioritize ALL given code smells found in a software project.
Each smell represents a concrete instance of technical debt and must be evaluated independently.

IMPORTANT CONSTRAINTS (READ CAREFULLY):
- The order in which smells are presented is ARBITRARY and MUST NOT influence prioritization.
- You must evaluate each smell independently BEFORE producing a global ranking.
- You must include ALL smells exactly once in the final ranking.
- Do NOT merge, drop, or group smells, even if they are similar.
- Use ONLY the provided information. Do not invent missing data.

---

## PHASE 1 — INDEPENDENT EVALUATION (INTERNAL)

For each smell (identified by its unique Id), internally assess its priority using the following dimensions:

- **Severity**: How harmful is the smell to maintainability, correctness, or evolution?
- **Change & Fault Risk**: Evidence of change-proneness, churn, or defect association.
- **Propagation Risk**: Likelihood that the smell affects other components.
- **Criticality**: Importance of the affected file/module in the system.
- **Refactoring Cost vs Benefit**: Expected payoff relative to effort.

Each smell MUST be assessed in isolation.
Do NOT compare smells during this phase.
Do NOT assume relative importance based on presentation order.

(Do not output this phase.)

---

## PHASE 2 — GLOBAL PRIORITIZATION

After evaluating all smells independently, produce a single global ranking.

Ranking rules:
- Higher severity and higher propagation risk rank first.
- Break ties using: criticality → change/fault risk → refactoring benefit.
- If still tied, rank the smell with broader architectural impact higher.

---

## OUTPUT FORMAT (STRICT)

Output ONLY the ranked list using the following pipe-separated format:

Rank|Id|Name of Smell|Name|File|Reason for Prioritization

Rules:
- Rank must start at 1 and be sequential.
- Id must match the smell Id exactly.
- The Reason must be concise, technical, and grounded in the provided evidence.
- Do NOT include any text outside the table.

---

## CODE SMELLS (OBJECTS TO BE RANKED)

SMELL
- id: 17
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: calculate_change_proneness
- line_number: 163.0

DESCRIPTION
'calculate_change_proneness' has 144 lines in ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py at line 163

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_change_proneness` function spans 144 lines, performing commit retrieval, change counting, frequency and density calculations, author ownership analysis, and summary statistics all in one block. This concentration of diverse logic in a single method makes the code hard to read, hampers unit testing, and increases the chance of subtle bugs slipping through. The method’s size also obscures the flow of data, making future modifications error‑prone and slowing down maintenance.


SMELL
- id: 16
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: calculate_change_frequency
- line_number: 23.0

DESCRIPTION
'calculate_change_frequency' has 98 lines in ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py at line 23

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_change_frequency` function spans almost a hundred lines, intertwining branch selection, commit iteration, diff parsing, statistics aggregation, and DataFrame construction. This concentration of responsibilities makes the method hard to understand, modify, or test in isolation, as changes to one part (e.g., diff handling) can inadvertently affect unrelated logic. The tight coupling also raises defect risk, since bugs in commit filtering or line counting may propagate silently through the entire calculation pipeline.


SMELL
- id: 3
- type_of_smell: Structural
- name: Long File
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: gitmetrics.metrics.change_proneness
- line_number: nan

DESCRIPTION
File 'gitmetrics.metrics.change_proneness' has 357 meaningful lines of code

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The change_proneness module spans 357 meaningful lines, far exceeding typical single‑file size guidelines. Its length forces developers to sift through extensive nested loops, repeated error handling, and multiple metrics calculations, which raises cognitive load and makes locating defects more difficult. The dense, intertwined logic also hampers testability, as many execution paths must be exercised to achieve coverage, increasing the likelihood of undiscovered bugs.


SMELL
- id: 15
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: calculate_cohesion
- line_number: 466.0

DESCRIPTION
Method 'calculate_cohesion' makes 4 calls to 'os' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/coupling.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_cohesion` function exhibits Feature Envy by heavily relying on the `os` module and file‑system operations instead of working primarily with its own data structures. This external dependency makes the method brittle, as changes to the repository layout or file‑system behavior can break it. The tight coupling to I/O also hampers unit testing, requiring complex mocks or real repositories, and increases defect risk from unexpected file‑access errors.


SMELL
- id: 6
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/co_change.py
- module_or_class: calculate_co_change_matrix
- line_number: 50.0

DESCRIPTION
'calculate_co_change_matrix' has 60 lines in ../projects/gitmetrics/gitmetrics/metrics/co_change.py at line 50

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/co_change.py

--- Static Code Metrics ---
- Lines of Code (LOC): 244
- Number of Classes: 0
- Number of Functions: 3
- Imports: 7
- Average Cyclomatic Complexity: 12.00
- Maximum Cyclomatic Complexity: 15
- Maintainability Index: 62.33

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_co_change_matrix` method is lengthy, performing several distinct tasks—branch resolution, commit iteration, file and pair counting, filtering, DataFrame construction, and metadata aggregation—all within a single function. This concentration of responsibilities makes the code harder to understand, maintain, and test, as changes to one part (e.g., the filtering logic) risk unintentionally affecting another (e.g., the matrix population). The resulting high cognitive load and tight coupling increase the likelihood of defects and make future extensions more error‑prone.


SMELL
- id: 14
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: calculate_semantic_coupling
- line_number: 240.0

DESCRIPTION
Method 'calculate_semantic_coupling' makes 8 calls to 'os' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/coupling.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_semantic_coupling` function exhibits Feature Envy by calling the `os` module eight times while never invoking any of its own helper methods. This heavy reliance on an external library makes the method brittle—any change to path handling or the underlying filesystem API could break the logic. The tight coupling to `os` also hampers testability, as unit tests must mock many external calls, increasing the chance of defects slipping through.


SMELL
- id: 18
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: calculate_error_proneness
- line_number: 359.0

DESCRIPTION
'calculate_error_proneness' has 134 lines in ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py at line 359

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_error_proneness` function spans 134 lines, performing commit retrieval, error handling, regex compilation, bug counting, file content extraction, density and frequency calculations, and summary statistics all in one block. This concentration of responsibilities makes the method difficult to understand, modify, or extend, increasing the likelihood of bugs when changes are made. The lack of clear separation also hampers unit testing, as many external dependencies and side effects are intertwined within the same function. Overall, the long method raises maintainability and defect risk for future development.


SMELL
- id: 13
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: calculate_structural_coupling
- line_number: 58.0

DESCRIPTION
Method 'calculate_structural_coupling' makes 7 calls to 'commit' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/coupling.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_structural_coupling` function is heavily dependent on the `commit` object, calling its properties and methods (e.g., `parents`, `tree.traverse`, `hexsha`, `diff`) throughout the routine while performing only a modest amount of its own logic. This feature envy makes the method tightly coupled to the commit API, so any change in the commit interface or behavior can ripple through the calculation logic, increasing maintenance effort and making unit testing harder because the function must be exercised with real commit objects or complex mocks. The resulting fragility can raise defect risk, especially when the repository structure or commit semantics evolve.


SMELL
- id: 23
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/utils/logger.py
- module_or_class: get_logger
- line_number: 59.0

DESCRIPTION
Method 'get_logger' makes 5 calls to 'logging' but only 0 local calls in ../projects/gitmetrics/gitmetrics/utils/logger.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/utils/logger.py

--- Static Code Metrics ---
- Lines of Code (LOC): 85
- Number of Classes: 0
- Number of Functions: 2
- Imports: 4
- Average Cyclomatic Complexity: 4.00
- Maximum Cyclomatic Complexity: 5
- Maintainability Index: 84.69

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
No major maintainability risks detected.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `get_logger` function exhibits Feature Envy by delegating almost all of its work to the external `logging` module—creating a logger, setting its level, and configuring a handler—while it itself performs no meaningful internal logic. This heavy reliance on another component makes the function fragile to changes in the logging API and hard to unit‑test in isolation, increasing the risk of defects when the logging configuration evolves. Consequently, the code’s maintainability suffers because future modifications to logging behavior require touching this helper rather than the calling code.


SMELL
- id: 7
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/co_change.py
- module_or_class: calculate_co_change_metrics
- line_number: 148.0

DESCRIPTION
'calculate_co_change_metrics' has 69 lines in ../projects/gitmetrics/gitmetrics/metrics/co_change.py at line 148

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/co_change.py

--- Static Code Metrics ---
- Lines of Code (LOC): 244
- Number of Classes: 0
- Number of Functions: 3
- Imports: 7
- Average Cyclomatic Complexity: 12.00
- Maximum Cyclomatic Complexity: 15
- Maintainability Index: 62.33

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_co_change_metrics` function spans 69 lines and bundles several distinct responsibilities—computing the co‑change matrix, calculating coupling strengths, extracting top pairs, averaging coupling per file, sorting, and assembling the final result—into a single routine. This concentration of logic makes the code harder to read and reason about, increasing cognitive load for developers and complicating unit testing because many internal states and loops must be exercised. The nested loops and repeated index lookups also raise the risk of subtle bugs and performance issues as repository size grows. Overall, the method’s length and complexity degrade maintainability, testability, and elevate defect risk.


SMELL
- id: 10
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: calculate_structural_coupling
- line_number: 58.0

DESCRIPTION
'calculate_structural_coupling' has 122 lines in ../projects/gitmetrics/gitmetrics/metrics/coupling.py at line 58

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_structural_coupling` function is heavily dependent on the `commit` object, calling its properties and methods (e.g., `parents`, `tree.traverse`, `hexsha`, `diff`) throughout the routine while performing only a modest amount of its own logic. This feature envy makes the method tightly coupled to the commit API, so any change in the commit interface or behavior can ripple through the calculation logic, increasing maintenance effort and making unit testing harder because the function must be exercised with real commit objects or complex mocks. The resulting fragility can raise defect risk, especially when the repository structure or commit semantics evolve.


SMELL
- id: 2
- type_of_smell: Structural
- name: Long File
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: gitmetrics.metrics.coupling
- line_number: nan

DESCRIPTION
File 'gitmetrics.metrics.coupling' has 333 meaningful lines of code

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The coupling.py module contains 333 meaningful lines, far exceeding typical thresholds for a single file. Its breadth of responsibilities—extracting modules, computing structural, semantic, and cohesion metrics, and building graph visualizations—creates a dense, monolithic implementation that is difficult to read and reason about. This complexity raises maintenance costs, makes unit testing fragile, and increases the likelihood of subtle bugs slipping through, especially when changes in one area inadvertently affect unrelated calculations.


SMELL
- id: 20
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: calculate_change_proneness
- line_number: 163.0

DESCRIPTION
Method 'calculate_change_proneness' makes 10 calls to 'diff' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_change_proneness` function spans 144 lines, performing commit retrieval, change counting, frequency and density calculations, author ownership analysis, and summary statistics all in one block. This concentration of diverse logic in a single method makes the code hard to read, hampers unit testing, and increases the chance of subtle bugs slipping through. The method’s size also obscures the flow of data, making future modifications error‑prone and slowing down maintenance.


SMELL
- id: 12
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: calculate_cohesion
- line_number: 466.0

DESCRIPTION
'calculate_cohesion' has 64 lines in ../projects/gitmetrics/gitmetrics/metrics/coupling.py at line 466

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_cohesion` function exhibits Feature Envy by heavily relying on the `os` module and file‑system operations instead of working primarily with its own data structures. This external dependency makes the method brittle, as changes to the repository layout or file‑system behavior can break it. The tight coupling to I/O also hampers unit testing, requiring complex mocks or real repositories, and increases defect risk from unexpected file‑access errors.


SMELL
- id: 11
- type_of_smell: Code
- name: Long Method
- file_path: ../projects/gitmetrics/gitmetrics/metrics/coupling.py
- module_or_class: calculate_semantic_coupling
- line_number: 240.0

DESCRIPTION
'calculate_semantic_coupling' has 151 lines in ../projects/gitmetrics/gitmetrics/metrics/coupling.py at line 240

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/coupling.py

--- Static Code Metrics ---
- Lines of Code (LOC): 574
- Number of Classes: 0
- Number of Functions: 4
- Imports: 9
- Average Cyclomatic Complexity: 24.00
- Maximum Cyclomatic Complexity: 42
- Maintainability Index: 40.87

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_semantic_coupling` function exhibits Feature Envy by calling the `os` module eight times while never invoking any of its own helper methods. This heavy reliance on an external library makes the method brittle—any change to path handling or the underlying filesystem API could break the logic. The tight coupling to `os` also hampers testability, as unit tests must mock many external calls, increasing the chance of defects slipping through.


SMELL
- id: 22
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/utils/logger.py
- module_or_class: setup_logging
- line_number: 13.0

DESCRIPTION
Method 'setup_logging' makes 5 calls to 'root_logger' but only 0 local calls in ../projects/gitmetrics/gitmetrics/utils/logger.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/utils/logger.py

--- Static Code Metrics ---
- Lines of Code (LOC): 85
- Number of Classes: 0
- Number of Functions: 2
- Imports: 4
- Average Cyclomatic Complexity: 4.00
- Maximum Cyclomatic Complexity: 5
- Maintainability Index: 84.69

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
No major maintainability risks detected.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `setup_logging` function is heavily dependent on the global `root_logger`, making five distinct calls to it while performing no local logic. This indicates a Feature Envy smell, as the method is more interested in configuring an external logger than in manipulating its own state. Such tight coupling to a global object can make the code harder to maintain, difficult to unit‑test in isolation, and increases the risk of unintended side effects when the logging configuration changes elsewhere.


SMELL
- id: 5
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/cli.py
- module_or_class: main
- line_number: 62.0

DESCRIPTION
Method 'main' makes 15 calls to 'args' but only 0 local calls in ../projects/gitmetrics/gitmetrics/cli.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/cli.py

--- Static Code Metrics ---
- Lines of Code (LOC): 116
- Number of Classes: 0
- Number of Functions: 2
- Imports: 8
- Average Cyclomatic Complexity: 6.50
- Maximum Cyclomatic Complexity: 12
- Maintainability Index: 71.77

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
Slightly reduced maintainability; monitor this file over time.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `main` function is heavily dependent on the `args` object, making many calls to its attributes while performing no work of its own, which is a classic case of Feature Envy. This tight coupling to the argument parser makes the method brittle; any change to the argument structure forces modifications in `main`. As a result, maintainability suffers, unit testing becomes more complex due to the need to mock a large number of argument fields, and the risk of defects rises because the function’s behavior is tightly bound to external input.


SMELL
- id: 19
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: calculate_change_frequency
- line_number: 23.0

DESCRIPTION
Method 'calculate_change_frequency' makes 7 calls to 'commit' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_change_frequency` function spans almost a hundred lines, intertwining branch selection, commit iteration, diff parsing, statistics aggregation, and DataFrame construction. This concentration of responsibilities makes the method hard to understand, modify, or test in isolation, as changes to one part (e.g., diff handling) can inadvertently affect unrelated logic. The tight coupling also raises defect risk, since bugs in commit filtering or line counting may propagate silently through the entire calculation pipeline.


SMELL
- id: 8
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/co_change.py
- module_or_class: get_changed_files
- line_number: 21.0

DESCRIPTION
Method 'get_changed_files' makes 6 calls to 'diff' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/co_change.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/co_change.py

--- Static Code Metrics ---
- Lines of Code (LOC): 244
- Number of Classes: 0
- Number of Functions: 3
- Imports: 7
- Average Cyclomatic Complexity: 12.00
- Maximum Cyclomatic Complexity: 15
- Maintainability Index: 62.33

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `get_changed_files` function exhibits Feature Envy by delegating almost all of its work to the `diff` method of the parent commit, with no substantial local logic beyond collecting paths. This tight coupling to the external diff API makes the method fragile to changes in the underlying Git library and hard to unit‑test in isolation. As a result, maintainability suffers because any refactor of the diff interface or commit structure will require updates to this function, and defect risk rises due to the high dependency on external behavior.


SMELL
- id: 9
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/co_change.py
- module_or_class: calculate_co_change_metrics
- line_number: 148.0

DESCRIPTION
Method 'calculate_co_change_metrics' makes 15 calls to 'matrix' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/co_change.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/co_change.py

--- Static Code Metrics ---
- Lines of Code (LOC): 244
- Number of Classes: 0
- Number of Functions: 3
- Imports: 7
- Average Cyclomatic Complexity: 12.00
- Maximum Cyclomatic Complexity: 15
- Maintainability Index: 62.33

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_co_change_metrics` function spans 69 lines and bundles several distinct responsibilities—computing the co‑change matrix, calculating coupling strengths, extracting top pairs, averaging coupling per file, sorting, and assembling the final result—into a single routine. This concentration of logic makes the code harder to read and reason about, increasing cognitive load for developers and complicating unit testing because many internal states and loops must be exercised. The nested loops and repeated index lookups also raise the risk of subtle bugs and performance issues as repository size grows. Overall, the method’s length and complexity degrade maintainability, testability, and elevate defect risk.


SMELL
- id: 1
- type_of_smell: Structural
- name: High Cyclomatic Complexity
- file_path: ../projects/gitmetrics/gitmetrics/core/repository.py
- module_or_class: gitmetrics.core.repository.GitRepository
- line_number: 283.0

DESCRIPTION
Method 'get_lines_of_code' has cyclomatic complexity of 15

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/core/repository.py

--- Static Code Metrics ---
- Lines of Code (LOC): 520
- Number of Classes: 1
- Number of Functions: 13
- Imports: 14
- Average Cyclomatic Complexity: 5.46
- Maximum Cyclomatic Complexity: 14
- Maintainability Index: 46.23

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `get_lines_of_code` method contains numerous conditional branches, nested loops, and a large dictionary of comment patterns, which together raise its cyclomatic complexity to 15. This high complexity makes the code difficult to read and reason about, increasing the likelihood of subtle bugs slipping through. It also hampers testability, as many execution paths must be covered to achieve adequate test coverage, and it raises maintenance costs when future changes are required.


SMELL
- id: 4
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/cli.py
- module_or_class: parse_args
- line_number: 21.0

DESCRIPTION
Method 'parse_args' makes 5 calls to 'parser' but only 0 local calls in ../projects/gitmetrics/gitmetrics/cli.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/cli.py

--- Static Code Metrics ---
- Lines of Code (LOC): 116
- Number of Classes: 0
- Number of Functions: 2
- Imports: 8
- Average Cyclomatic Complexity: 6.50
- Maximum Cyclomatic Complexity: 12
- Maintainability Index: 71.77

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
Slightly reduced maintainability; monitor this file over time.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `parse_args` function is heavily coupled to the `argparse.ArgumentParser` object, making five calls to configure it while performing no local logic. This tight reliance on the parser indicates a Feature Envy smell, as the function’s behavior is dominated by another object's interface rather than its own responsibilities. Such coupling can reduce maintainability, making changes to argument handling brittle, and it also hampers testability because the function is difficult to isolate from the argparse machinery, potentially increasing defect risk when argument parsing logic evolves.


SMELL
- id: 21
- type_of_smell: Code
- name: Feature Envy
- file_path: ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py
- module_or_class: calculate_error_proneness
- line_number: 359.0

DESCRIPTION
Method 'calculate_error_proneness' makes 9 calls to 'file_bugs' but only 0 local calls in ../projects/gitmetrics/gitmetrics/metrics/change_proneness.py

GIT_ANALYSIS
No Git history found for the analyzed files.

PYLINT_REPORT
### File Analysis Report: projects/gitmetrics/gitmetrics/metrics/change_proneness.py

--- Static Code Metrics ---
- Lines of Code (LOC): 534
- Number of Classes: 0
- Number of Functions: 3
- Imports: 9
- Average Cyclomatic Complexity: 26.67
- Maximum Cyclomatic Complexity: 34
- Maintainability Index: 39.08

--- Pylint Summary ---
- Convention issues: 0
- Refactor suggestions: 0
- Warnings: 0
- Errors: 0
- Fatal errors: 0

--- Example Lint Messages ---
No specific linting issues found.

--- Interpretation ---
High cyclomatic complexity indicates dense logical branching. Low maintainability index suggests high technical debt risk. The file size is large, which may indicate a 'Large File' smell.

--- Instruction for LLM ---
Use this report to evaluate how maintainable, complex, or stylistically consistent the file is.
When prioritizing technical debt, files with higher complexity, lower maintainability index,
or multiple convention/refactor issues should be ranked higher.

AI SUMMARIZATION OF THE CODE
The `calculate_error_proneness` function spans 134 lines, performing commit retrieval, error handling, regex compilation, bug counting, file content extraction, density and frequency calculations, and summary statistics all in one block. This concentration of responsibilities makes the method difficult to understand, modify, or extend, increasing the likelihood of bugs when changes are made. The lack of clear separation also hampers unit testing, as many external dependencies and side effects are intertwined within the same function. Overall, the long method raises maintainability and defect risk for future development.



---

## BACKGROUND KNOWLEDGE (GENERAL GUIDANCE ONLY)
The following documents provide general insights about technical debt and code smells.
They must NOT be treated as smell-specific evidence.


.
considered Technical Debt (TD). The refactoring process
boosts the performance of the software code [4]. Since refac-
toring some smells can be an expensive and time-consuming
affair [5], therefore, the priority of smells needs to be realized
in the early stages only. The prioritization of code smell
can also be represented as a severity index, as proposed by
Fontana et al. [6].
Apart from the severity of code smells, during the software
releases, the changes in the software modules or classes
also need to be dealt with. Experts frequently look at mul-
tiple updates to get historical information regarding soft-
ware project development. Early recognition of modules that
inculcate smells can be valuable for the team handling soft-
ware maintenance and assigning substantial testing resources
with a higher probability of alteration in software mod-
ules. Software-changing impact analysis has been previously

code can impact software maintainability is pensive. Uncov-
ering many code quality issues due to smells in the code,
parallelly influences the criticality of smells in the software
world from the refactoring phase. Realizing the severity of
smell, among others, gives the developer community an edge
for optimization at the earliest.
A tool designed for ranking code smells was suggested
in 2015 by Vidal et al. [25]. The tool uses a blend of
three factors: historical changes to components (for stability
assessment), critical system modifiability scenarios, and the
significance of the code smell. Its value is subjective as the
developer can indicate how harmful the smell is. The thresh-
old for identifying a code smell may differ across developers
and systems. The researchers propose a tool called SPIRIT,
that ranks the severity of code smells in a system, considering
its criticality. They evaluated the approach in two case studies
and found the results helpful to developers. Another method
Fontana proposed involves applying strong and weak filters
to reduce the number of code smell detection outcomes.
However, this method is limited to code smells of only five
types [26].
Ratiu et al. used historical data of suspected flaw-related
structures as a metric-based detection strategy to express
code smells regarding thresholds [27]. Other studies have
also explored the use of system history to predict classes that
are likely to change in the future based on those that have

erature. The contribution of this work would help the software
developers prioritize the code smells in the pre-refactoring
phase, thus saving ample time and resources spent in the
development of projects. Subsequently, examining the behav-
ior of the severity trend of code smell gives a glimpse to the
developers for managing the code smells in the forthcoming
releases for the primary software system. This work encour-
ages the researchers to further explore Python code smells
to explore the diffusion and criticalness among the smells.
In addition, co-occurrences of Python smells can be explored
by prioritising them and exploring the critical smells to be
refactored simultaneously.

et al. 2012). Our work confirms the results achieved by Khomh et al. (2012) on a larger
set of code smells and software systems, an provides some complementary hints about
the phenomenon. In particular, other than studying the change- and fault-proneness of
smelly and non-smelly classes, we analyzed how such indicators vary when the smells
identified are removed. Also, we use the SZZ algorithm (Sliwerski et al. 2005) to bet-
ter investigate the temporal relationship between the presence of code smells and fault
introduction.
Gatrell and Counsell (2015) conducted an empirical study aimed at quantifying the effect
of refactoring on class change- and fault-proneness. In particular, they monitored a com-
mercial C# system for twelve months identifying the refactorings applied during the first
four months. They examined the same classes for the second four months in order to deter-
mine whether the refactoring results in a decrease of change- and fault-proneness. They also
compared such classes with the classes of the system that were not refactored in the same
period. Results revealed that classes subject to refactoring have a lower change- and fault-
proneness. It is worth noting that Gatrell and Counsell did not focus their attention on well
known design problems (i.e., code smells) but they analyzed if refactored classes regard-
less of the presence of a design problem. Instead, our study investigates the actual impact
Empir Software Eng (2018) 23:1
– 1
1
1
88
22
1192

A. Gupta et al.: Severity Assessment of Python Code Smells
predicted improvement to software maintainability. While
analyzing the two systems, they did not establish an Intensity
Index for code smells.
Fontana et al. [6] have previously presented a study similar
to the presented research, where they introduced the Code
Smelly Intensity Index as a criterion for prioritizing code
smells. Our study also incorporates this approach, although
Fontana’s method was limited to a specific set of code smells.
An approach has been followed in this study that addresses
exploring the Python code smells and analyzing their behav-
ior (change proneness) over a modification period, thereby
focusing on the criticality of the smell through severity inten-
sity values, which can help the developers realize the impor-
tance of particular smell in pre refactoring phase thus, saving
time and resources.
Code smells are researched in several languages, including
Java, C, C++, Kotlin, etc. To the best of our knowledge,
plenty of content doesn’t address Python code smells. Given
how frequently Python is used these days, the behavior of
code smells in Python software needs to be addressed. This
study aims to evaluate the severity of Python code smells so
they can be promptly fixed or removed.
III. METHODOLOGY/ WORKFLOW OF THE WORK
This research escalates the study of the diffusion of code
smells in Python software for severity assessments at the class

the previous work by Palomba et al. (2014). Rather than looking at developers’ perception,
this paper observes the possible effect of smells in terms of change- and fault-proneness.
3 Study definition and planning
The goal of this study is to analyze the diffuseness of 13 code smell types in real software
applications and to assess their impact on code change- and fault-proneness. It is worth
remarking that the term “diffuseness”, when associated to a code smell type, refers to the
percentage of code components in a system affected by at least one instance of the smell
type. Analyzing the diffuseness of code smells is a preliminary analysis needed to better
interpret their effect on change- and fault-proneness. Indeed, some smells might be highly
correlated with fault-proneness but rarely diffused in software projects or vice versa. The
13 code smell types considered in this study are listed in Table 1 together with a short
description.
3.1 Research questions and planning
We formulated the following three research questions:
–
RQ1: What is the diffuseness of code smells in software systems? This is a preliminary
research question aiming at assessing to what extent software systems are affected by
code smells.
–
RQ2: To what extent do classes affected by code smells exhibit a different level
of change- and fault-proneness with respect to non-smelly classes? Previous work
(Khomh et al. 2012) found that classes affected by at least one smell have a higher

on software maintenance, code smells are behavioral in nature. Python is widely used for various software
engineering activities and tends tool to contain code smells that affect its quality. This study investigates
five code smells diffused in 20 Python software comprising 10550 classes and analyses its severity index
using metric distribution at the class level. Subsequently, a behavioral analysis has been conducted over the
considered modification period (phases) for the code smell undergoing class change proneness. Furthermore,
it helps to investigate the accurate multinomial classifier for mining the severity index. It witnesses the change
in severity at the class level over the modification period by mapping its characteristics over various statistical
functions and hypotheses. Our findings reveal that the Cognitive Complexity of code smell is the most severe
one. The remaining four smells are centered around the moderate range, having an average severity index
value. The results suggest that the J48 algorithm was the accurate multinomial classifier for classifying the
severity of code smells with 92.98% accuracy in combination with the AdaBoost method. The findings of
our empirical evaluation can be beneficial for the software developers to prioritize the code smells in the
pre-refactoring phase and can help manage the code smells in forthcoming releases, subsequently saving
ample time and resources spent in the development and maintenance of software projects.

pre-refactoring phase and can help manage the code smells in forthcoming releases, subsequently saving
ample time and resources spent in the development and maintenance of software projects.
INDEX TERMS Software maintenance, code smell severity, cognitive complexity code smell, class change
proneness, open-source software, Python, sustainable software.
I. INTRODUCTION
The code quality of the software is a significant factor that
majorly contributes to software maintenance. Beck et al. [1],
[2] introduced the concept of code smells, which are blips
in software code due to its improper software design and
development by the application programmer. These mainly
emerge from developer actions taken at times of emergencies,
careless implementation or by using subpar coding solutions.
It is believed that code smells, being design flaws, harm
the quality of the code [1], [2]. Conceptually, they classify
the violations in software that follow object-oriented design
approaches such as data abstraction, encapsulation, mod-
ularity, and hierarchy [3]. Moreover, code smells are also
The associate editor coordinating the review of this manuscript and
approving it for publication was Porfirio Tramontana
.
considered Technical Debt (TD). The refactoring process
boosts the performance of the software code [4]. Since refac-
toring some smells can be an expensive and time-consuming
affair [5], therefore, the priority of smells needs to be realized

6 Discussion and conclusion
This paper reported a large study conducted on 395 releases of 30 Java open source projects,
aimed at understanding the diffuseness of code smells in Java open source projects and
their relation with source code change- and fault-proneness. The study considered 17,350
instances of 13 different code smell types, firstly detected using a metric-based approach
and then manually validated.
The results highlighted the following findings:
–
Diffuseness of smells. The most diffused smells are the one related to size and com-
plexity such as Long Method, Spaghetti Code, and to some extent Complex Class or
God Class. This seems to suggests that a simple metric-based monitoring of code qual-
ity could already give enough indications about the presence of poor design decisions
or in general of poor code quality. Smells not related to size like Message Chains and
Lazy Class are less diffused, although there are also cases of such smells with high
diffuseness, see for example Class Data Should Be Private and Speculative Generality.
–
Relation with change- and fault-proneness. Generally speaking, our results confirm
the results of the previous study by Khomh et al. (2012), i.e., classes affected by code
smells tend to be more change- and fault-prone than others, and that this is even more
evident when classes are affected by multiple smells. At the same time, if we analyze
the fault-proneness results for specific types of smells, we can also notice that high

and considered 13 different kinds of code smells. More specifically, the study aims at
investigating:
1.
the diffuseness of code smells in open source systems. If the magnitude of the phe-
nomenon is small—i.e.,
code smells, or some specific kinds of code smells, are
poorly diffused—then studying their impact on the code maintainability might not be
worthwhile.
2.
the impact of code smells on maintenance properties and specifically on code change-
and fault-proneness. We intend to investigate to what extent the previous findings
reported by Khomh et al. (2012) and D’Ambros et al. (2010)—obtained on a smaller set
of software systems and based on smell instances automatically identified using code
smell detectors—are confirmed on a larger set of 395 software releases and considering
manually validated smell instances.
To the best of our knowledge, this is to date the largest study investigating the relation-
ship between the presence of code smells and source code change- and fault-proneness. In
addition, and to cope with the other limitations of previous studies mentioned above, this
paper (i) relies on a set of manually-validated code smells rather than just on the output
Empir Software Eng (2018) 23:1
– 1
1
1
88
22
1190


---

## PROJECT STRUCTURE (CONTEXTUAL AWARENESS)
├── gitmetrics/
│   ├── requirements.txt
│   ├── README.md
│   ├── setup.py
│   ├── tests/
│   │   ├── __init__.py
│   ├── output/
│   │   ├── metrics.json
│   ├── gitmetrics.egg-info/
│   │   ├── PKG-INFO
│   │   ├── SOURCES.txt
│   │   ├── entry_points.txt
│   │   ├── requires.txt
│   │   ├── top_level.txt
│   │   ├── dependency_links.txt
│   ├── gitmetrics/
│   │   ├── __init__.py
│   │   ├── cli.py
│   │   ├── metrics/
│   │   │   ├── co_change.py
│   │   │   ├── coupling.py
│   │   │   ├── __init__.py
│   │   │   ├── change_proneness.py
│   │   ├── core/
│   │   │   ├── __init__.py
│   │   │   ├── metrics_collector.py
│   │   │   ├── repository.py
│   │   ├── utils/
│   │   │   ├── __init__.py
│   │   │   ├── logger.py
│   ├── .vscode/
│   │   ├── settings.json

---

## QUESTION
Using evidence from the provided embedded research (INFO ON CODE SMELLS AND TECHNICAL DEBT),        rank ALL code smells by refactoring priority. For each smell, justify the rank using research-backed        signals such as change-proneness, fault/defect-proneness (bug association), smell severity/metrics        (e.g., size, complexity), and expected refactoring ROI (cost vs benefit).        If the research suggests a relevant principle (e.g., smells correlate with higher change-proneness),        apply it explicitly to the smell's available metrics (git stats, churn, recency, complexity, lint).

Now produce the final ranked prioritization list."
